import { prisma } from "@/lib/db";
import { env } from "@/lib/env";
import { allowedActionsForTrust } from "@/lib/policy";
import { getCustomerByDomain, getDomainFromRequest } from "@/lib/domain";

export async function POST(req: Request) {
  const body = await req.json().catch(() => ({}));
  const url = new URL(req.url);
  const domain = url.searchParams.get("domain") || body?.domain || getDomainFromRequest(req) || env.NEXT_PUBLIC_DEMO_DOMAIN || "sunnysteps.com";
  const ruleSetId: string = body?.ruleSetId;
  if (!ruleSetId) return Response.json({ ok: false, error: "missing_ruleSetId" }, { status: 400 });

  const customer = await getCustomerByDomain(domain).catch(() => null);
  if (!customer) return Response.json({ ok: false, error: "customer_not_found" }, { status: 404 });

  const ruleSet = await prisma.ruleSet.findUnique({ where: { id: ruleSetId } });
  if (!ruleSet) return Response.json({ ok: false, error: "ruleset_not_found" }, { status: 404 });

  const trust = await prisma.trustScoreSnapshot.findFirst({ where: { customerId: customer.id }, orderBy: { createdAt: "desc" } });
  const trustTotal = trust?.total ?? 70;
  const policy = allowedActionsForTrust(trustTotal);

  await prisma.activityEvent.create({
    data: {
      customerId: customer.id,
      kind: "policy_checked",
      summary: `Policy checked for growth: trust ${trustTotal}/100 (${policy.zone}).`,
      payload: { trustTotal, policy },
    },
  });

  // Real segmentation using EndCustomer attributes.
  const cfg = (ruleSet.json || {}) as any;
  const conditions = cfg?.conditions || {};
  const ratingGte = Number(conditions?.ratingGte ?? 0);
  const sentimentEq = String(conditions?.sentiment ?? "").toLowerCase();
  const referralSentMustBe = conditions?.referralSent;

  const endCustomers = await prisma.endCustomer.findMany({ where: { customerId: customer.id } });
  const eligible: string[] = [];
  const suppressed: Array<{ email: string; reason: string }> = [];
  const reasons: Record<string, number> = {};

  for (const ec of endCustomers) {
    const attrs = (ec.attributes || {}) as any;
    const rating = Number(attrs?.rating);
    const sentiment = String(attrs?.sentiment || "").toLowerCase();
    const referralSent = Boolean(attrs?.referralSent);

    let reason: string | null = null;
    if (!Number.isFinite(rating)) reason = "missing_rating";
    else if (ratingGte && rating < ratingGte) reason = `rating_below_${ratingGte}`;
    else if (sentimentEq && sentiment !== sentimentEq) reason = "non_matching_sentiment";
    else if (typeof referralSentMustBe === "boolean" && referralSent !== referralSentMustBe) reason = "referral_state_mismatch";

    if (reason) {
      suppressed.push({ email: ec.email, reason });
      reasons[reason] = (reasons[reason] || 0) + 1;
    } else {
      eligible.push(ec.email);
    }
  }

  const requiresApproval = false;
  const segmentSize = eligible.length;
  const suppressedSize = suppressed.length;

  const campaign = await prisma.campaign.create({
    data: {
      customerId: customer.id,
      ruleSetId: ruleSet.id,
      name: `Dry-run: ${ruleSet.name}`,
      goal: "Demonstrate trust-gated execution (dry-run by default)",
      status: "READY",
      dryRun: true,
      requiresApproval,
      segmentSize,
      suppressedSize,
      gatingSummary: { policy, trustTotal, requiresApproval, reasons, dryRun: true } as any,
      messages: {
        create: {
          channel: "email",
          subject: `Demo: ${ruleSet.name}`,
          body: "This is a dry-run campaign generated by TrustEye. No messages were sent.",
        },
      },
    },
  });

  const to = eligible.slice(0, 50);
  for (const recipient of to) {
    await prisma.sendReceipt.create({
      data: {
        campaignId: campaign.id,
        status: "DRY_RUN",
        to: recipient,
        channel: "email",
        provider: "dry_run",
        payload: { ruleSetId: ruleSet.id, dryRun: true } as any,
      },
    });
  }

  for (const s of suppressed.slice(0, 200)) {
    await prisma.sendReceipt.create({
      data: {
        campaignId: campaign.id,
        status: "SUPPRESSED",
        to: s.email,
        channel: "email",
        provider: "dry_run",
        payload: { ruleSetId: ruleSet.id, suppressed: true, reason: s.reason } as any,
      },
    });
  }

  await prisma.activityEvent.create({
    data: {
      customerId: customer.id,
      kind: "campaign_created",
      summary: `Campaign created (dry-run) from rule: ${ruleSet.name}.`,
      payload: { campaignId: campaign.id, ruleSetId: ruleSet.id, toCount: to.length },
    },
  });

  await prisma.activityEvent.create({
    data: {
      customerId: customer.id,
      kind: "receipts_written",
      summary: `Dry-run receipts written (${to.length}).`,
      payload: { campaignId: campaign.id },
    },
  });

  return Response.json({ ok: true, campaignId: campaign.id, requiresApproval, segmentSize, suppressedSize });
}


