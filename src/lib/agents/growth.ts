import type { AgentStep, GraphState, ReceiptRef } from "@/lib/agents/types";
import { env } from "@/lib/env";
import { getOrCreateCustomerByDomain } from "@/lib/customer";
import { prisma } from "@/lib/db";
import { allowedActionsForTrust } from "@/lib/policy";

function stepBase(agent: AgentStep["agent"]): AgentStep {
  return { agent, read: [], decide: [], do: [], receipts: [] };
}

function receipt(kind: string, summary: string, id?: string): ReceiptRef {
  return { kind, summary, id };
}

type RuleSetLite = { id: string; name: string };

export async function runGrowth(state: GraphState): Promise<{ step: AgentStep; patch: Partial<GraphState> }> {
  const step = stepBase("GrowthAgent");
  step.read.push("Intent graph + trust score + available Trust Pack assets (demo).");

  if (state.command === "launch_campaign") {
    step.decide.push("Create goal-based campaign plan; choose channel; default dry-run; ensure trust gating passes.");
    step.do.push("Select RuleSet, preview segment, create DRY_RUN campaign, and write receipts.");
    const domain = state.customerDomain || env.NEXT_PUBLIC_DEMO_DOMAIN || "reliablenissan.com";
    const customer = await getOrCreateCustomerByDomain(domain);

    const msg = (state.userMessage || "").toLowerCase();

    // Defensive: if Prisma client is out of date in a running dev instance, these models may be missing.
    const ruleSetModel = (prisma as any).ruleSet;
    const segmentSnapshotModel = (prisma as any).segmentSnapshot;

    const ruleSets: RuleSetLite[] = ruleSetModel
      ? ((await ruleSetModel.findMany({
          where: { customerId: customer.id, active: true },
          orderBy: { updatedAt: "desc" },
        })) as RuleSetLite[])
      : [];
    const defaultRule = ruleSets.find((r: RuleSetLite) => r.name.toLowerCase().includes("referral")) || ruleSets[0];
    const selected =
      ruleSets.find((r: RuleSetLite) => msg.includes(r.name.toLowerCase())) ||
      (msg.includes("review") ? ruleSets.find((r: RuleSetLite) => r.name.toLowerCase().includes("review")) : null) ||
      defaultRule;

    const trust = await prisma.trustScoreSnapshot.findFirst({
      where: { customerId: customer.id },
      orderBy: { createdAt: "desc" },
    });
    const total = trust?.total ?? 70;
    const policy = allowedActionsForTrust(total);

    step.receipts.push(receipt("policy_checked", `Policy checked: trust ${total}/100 (${policy.zone}).`));
    if (policy.zone === "UNSAFE") {
      step.decide.push("Blocked: trust zone UNSAFE.");
      step.receipts.push(receipt("policy_block", "Campaign creation blocked by trust policy (UNSAFE)."));
      await prisma.activityEvent.create({
        data: {
          customerId: customer.id,
          kind: "campaign_blocked",
          summary: "Campaign blocked by trust policy (UNSAFE).",
          payload: { trustTotal: total, policy },
        },
      });
      return { step, patch: {} };
    }

    // Preview segment (deterministic demo)
    const segmentSize = selected?.name?.toLowerCase().includes("referral") ? 42 : 120;
    const suppressedSize = selected?.name?.toLowerCase().includes("review request") ? 18 : 6;
    const reasons = selected?.name?.toLowerCase().includes("review request")
      ? { negative_sentiment: 9, open_case: 9 }
      : { trust_below_threshold: 4, opted_out: 2 };

    const segmentSnapshot =
      selected && segmentSnapshotModel
        ? await segmentSnapshotModel.create({
            data: {
              customerId: customer.id,
              ruleSetId: selected.id,
              size: segmentSize,
              suppressed: suppressedSize,
              reasons: reasons as any,
            },
          })
        : null;

    step.receipts.push(
      receipt(
        "segment_snapshot_created",
        `Segment snapshot created${selected ? ` for ${selected.name}` : ""}: size ${segmentSize}, suppressed ${suppressedSize}.`,
        segmentSnapshot?.id
      )
    );

    const requiresApproval = Boolean(selected?.name?.toLowerCase().includes("review request"));

    const campaign = await prisma.campaign.create({
      data: {
        customerId: customer.id,
        ruleSetId: selected?.id ?? null,
        name: `Dry-run: ${selected?.name || "Growth RuleSet"}`,
        goal: "Trust-gated execution (dry-run by default)",
        status: "READY",
        dryRun: true,
        requiresApproval,
        segmentSize,
        suppressedSize,
        gatingSummary: { policy, trustTotal: total, reasons, requiresApproval } as any,
        messages: {
          create: {
            channel: "email",
            subject: `Demo: ${selected?.name || "Growth RuleSet"}`,
            body: "This is a dry-run campaign generated by TrustEye. No messages were sent.",
            payload: { kind: "growth", ruleSetId: selected?.id } as any,
          },
        },
      },
      include: { messages: true },
    });

    const to = Array.from({ length: Math.min(5, segmentSize) }).map((_, i) => `demo.segment+${i + 1}@example.com`);
    for (const recipient of to) {
      await prisma.sendReceipt.create({
        data: {
          campaignId: campaign.id,
          status: "DRY_RUN",
          to: recipient,
          channel: "email",
          provider: "simulated",
          payload: { campaignId: campaign.id, ruleSetId: selected?.id } as any,
        },
      });
    }

    step.receipts.push(receipt("campaign_created", `Campaign created (dry-run): ${campaign.name}.`, campaign.id));
    step.receipts.push(receipt("receipts_written", `Receipts written: ${to.length} (dry-run).`));

    await prisma.activityEvent.create({
      data: {
        customerId: customer.id,
        kind: "campaign",
        summary: `Campaign created (dry-run) from ruleset ${selected?.name || "â€”"} with ${to.length} simulated recipients.`,
        payload: { campaignId: campaign.id, ruleSetId: selected?.id, trustTotal: total, policy, segmentSnapshotId: segmentSnapshot?.id },
      },
    });
  } else {
    step.decide.push("No Growth execution required for this command.");
  }

  return { step, patch: {} };
}
